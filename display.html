<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Edit Pixel Art</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
    <link rel="shortcut icon" href="./pixil-frame-0.png" type="image/x-icon">
    <style>
        body {
            display: flex;
            place-content: center;
            flex-direction: column;
            align-items: center;
            padding: 10px;
        }

        #pixelCanvas {
            border: 1px solid rgb(218, 216, 216);
            cursor: pointer;
        }

        #colorPicker {
            margin-top: 10px;
        }

        #eraserButton.active {
            background-color: rgb(7, 89, 7);
        }
    </style>
    <script src="https://html2canvas.hertzen.com/dist/html2canvas.min.js"></script>
</head>
<body>
    <div class="p-2">
        <div class="flex align-center">
            <a class="underline cursor-pointer text-blue-400 mr-2" href="/home.html">Home</a>
            <button class="p-1 w-full border rounded cursor-pointer" onclick="downloadPixelArt('png')">Download Pixel Art (PNG)</button>
            <div id="saveButton" class="text-center text border p-1 rounded w-full cursor-pointer">Save Art</div>
        </div>
        <div class="border rounded flex justify-between items-center p-1 mt-1">
            <label class="" for="artNameInput">Enter art name:</label>
            <input class="border rounded p-1" type="text" id="artNameInput" value="">
            <label for="colorPicker">Pick Color:</label>
            <input class="cursor-pointer" type="color" id="colorPicker" value="#000000">
        </div>
        <div class="flex justify-end mt-1">
            <button class="bg-red-500 p-1 rounded w-2/5 text-white" id="eraserButton" onclick="setEraserMode()">Eraser</button>
        </div>
        <p id="alertMessage" class="text-green-400 mt-2 text-center"></p>
    </div>

    <canvas id="pixelCanvas" width="1000" height="500"></canvas>

    <script>
        let isEraserMode = false;
        let isMouseDown = false;
        let width, height;
        const alertMessage = document.getElementById('alertMessage');
        const pixelCanvas = document.getElementById('pixelCanvas');
        const canvas = document.getElementById('pixelCanvas');
const context = canvas.getContext('2d', { willReadFrequently: true });

        // Fetch the pixel art data based on the art ID
        const artId = localStorage.getItem('artId');
        fetch(`https://pix-server.onrender.com/getArt/${artId}`)
            .then(response => response.json())
            .then(data => {
                // Render the pixel art grid
                const artNameInput = document.getElementById('artNameInput');
                artNameInput.value = data.art.artName;
                width = data.art.width;
                console.log(data.art.pixels)
                height = data.art.height;
                renderPixelArt(data.art.pixels, width, height);
            })
            .catch(error => {
                console.error('Error fetching pixel art:', error);
            });


            function renderPixelArt(pixels, width, height) {
    // Set the pixel grid dimensions
    pixelCanvas.width = width * 5; // 5 pixels per unit
    pixelCanvas.height = height * 5;

    // Clear the canvas
    context.clearRect(0, 0, pixelCanvas.width, pixelCanvas.height);

    // Create pixel elements based on the pixel data
    for (let i = 0; i < pixels.length; i += 4) {
        const index = i / 4;
        const x = (index % width) * 5;
        const y = Math.floor(index / width) * 5;

        // Extract RGBA values from the array
        const r = pixels[i];
        const g = pixels[i + 1];
        const b = pixels[i + 2];
        const a = pixels[i + 3] / 255; // Normalize alpha value

        // Convert RGBA values to a CSS color string
        const color = `rgba(${r}, ${g}, ${b}, ${a})`;

        context.fillStyle = color;
        context.fillRect(x, y, 5, 5);
    }

    // Add click event to the "Save Art" button
    const saveButton = document.getElementById('saveButton');
    saveButton.addEventListener('click', savePixelArt);
}



        function handleMouseDown(event) {
            isMouseDown = true;
            handleColorChange(event);
        }

        function handleMouseOver(event) {
            if (isMouseDown) {
                handleColorChange(event);
            }
        }


        function handleColorChange(event) {
    const rect = pixelCanvas.getBoundingClientRect();
    const x = Math.floor((event.clientX - rect.left) / 5) * 5;
    const y = Math.floor((event.clientY - rect.top) / 5) * 5;
    const color = isEraserMode ? 'transparent' : document.getElementById('colorPicker').value;

    if (isEraserMode) {
        // Clear the region with a transparent color
        context.clearRect(x, y, 5, 5);
    } else {
        // Draw a colored pixel
        context.fillStyle = color;
        context.fillRect(x, y, 5, 5);
    }
}

        function setEraserMode() {
            isEraserMode = !isEraserMode;
            // Toggle the 'active' class to highlight the active mode
            const eraserButton = document.querySelector('#eraserButton');
            eraserButton.classList.toggle('active', isEraserMode);
        }

        function downloadPixelArt(format) {
            if (format === 'png') {
                // Use html2canvas to capture the content of the canvas
                html2canvas(pixelCanvas, {
                    backgroundColor: null,
                    scale: 2, // Adjust scale for higher resolution
                }).then(canvas => {
                    // Convert the canvas content to a data URL
                    const dataURL = canvas.toDataURL('image/png');
                    alertMessage.innerText = 'PNG downloaded.';

                    // Create a download link for the user to download the PNG file
                    const downloadLink = document.createElement('a');
                    downloadLink.href = dataURL;
                    downloadLink.download = 'pixel_art.png';
                    document.body.appendChild(downloadLink);
                    downloadLink.click();
                    document.body.removeChild(downloadLink);
                });
            }
        }

        function savePixelArt() {
    const artName = document.getElementById('artNameInput').value;
    const userId = localStorage.getItem('userId');
    const artId = localStorage.getItem('artId'); // Get artId

    // Use html2canvas to capture the content of the pixel canvas
    html2canvas(canvas, {
        backgroundColor: null,
        scale: 1, // Adjust scale if needed
    }).then(canvas => {
        // Convert the canvas content to a data URL
        const dataURL = canvas.toDataURL('image/png');

        // Create a new image element
        const img = new Image();
        img.src = dataURL;

        // Extract the pixel data from the image
        img.onload = function () {
            const tempCanvas = document.createElement('canvas');
            const tempContext = tempCanvas.getContext('2d');
            tempCanvas.width = width;
            tempCanvas.height = height;
            tempContext.drawImage(img, 0, 0, width, height);

            // Get the pixel content as an array
            const pixelArray = Array.from(tempContext.getImageData(0, 0, width, height).data);

            // Send the data to the server (replace this with your server endpoint)
            fetch('https://pix-server.onrender.com/save', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ userId, artName, pixels: pixelArray, width, height, artId }), // Include artId
            })
            .then(response => response.json())
            .then(data => {
                const artNameInput = document.getElementById('artNameInput');
                artNameInput.value = artName;
                alertMessage.innerText = "Art saved successfully";
                // Optionally, you can handle success or show a message to the user
            })
            .catch(error => {
                console.error('Error saving art:', error);
                // Optionally, you can handle errors or show an error message to the user
            });
        };
    });
}

pixelCanvas.addEventListener('mousedown', handleMouseDown);
        pixelCanvas.addEventListener('mousemove', handleMouseOver);
        document.addEventListener('mouseup', () => {
            // Reset isMouseDown on mouseup event
            isMouseDown = false;
        });

    </script>
</body>
</html>
